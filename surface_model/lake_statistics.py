"""This script generates random, periodic landscapes with lakes and calculates the number of lakes, the mean and the variance of the lake size distribution.
The landscapes are generated by a spatial random field (SRF) with a given variogram. The variogram can be fitted to measured data or a model can be chosen.
The generated landscapes are transformed into binary fields with a threshold to distinguish between water and land.
The binary fields are then tessellated with tundra lake tiles to minimize boundary error.
The areas of the lakes are calculated and the number of lakes, the mean and the variance of the lake size distribution are returned.
The landscapes can be saved as files and exported as raster and shape files.
The script can be used in the command line with flags to generate landscapes with different parameters.
"""
class _Field():
    """A class to represent a field in the Random Landcover Class.
    """    
    def __init__(
            self,
            srf,
            name: str,
            lake_frac: float = None,
            filepath: str = None,
            
    ):
        """Initializes the field with the given parameters.

        Args:
            srf (class): A class to generate spatial random fields (SRF) by gstools.
            name (str): The name of the field.
            lake_frac (float, optional): The area fraction that is water. Defaults to None.
            filepath (str, optional): The filepath to the data. Defaults to None.
        """        
        self.srf = srf
        self.values = srf.all_fields[-1]
        self.name = name
        self.filepath = filepath
        self.lake_frac = lake_frac

class RLC():
    """A class to represent a Random Landcover by different fields.
    """    
    def __init__(
            self, 
            identifier: str = "", 
            model: str = "Gaussian",
            input_variogram: str = None,
            input_field: str = None, 
            cor_len: int = 1, 
            var: int = 2, 
            n: int = 128, 
            m: int = 128, 
            dx00: float = 300, 
            dy00: float = 300, 
            ntiles: int = 6, 
            outdir: str = './fields/'
    ):
        """Initializes the Random Landcover Class with the given parameters.

        Args:
            identifier (str, optional): A general identifier for the output files. Defaults to "".
            input_variogram (str, optional): The input filepath for a variogram. Defaults to None.
            input_field (str, optional): The input filepath for a field. Defaults to None.
            model (str, optional): The model used for the variogram. Defaults to "Gaussian".
            cor_len (int, optional): If no variogram is given: The correlation length. Defaults to 1.
            var (int, optional): If no variogram is given: The variance. Defaults to 2.
            n (int, optional): number of grid points in x-direction. Defaults to 128.
            m (int, optional): number of grid points in y-direction. Defaults to 128.
            dx00 (float, optional): domain length aka Lx [m]. Defaults to 300.
            dy00 (float, optional): domain width  aka Ly [m]. Defaults to 300.
            ntiles (int, optional): Number of tiles. Defaults to 6.
            outdir (str, optional): The output directory. Defaults to './'.
        """        
        
        #---------- Defining Model ------
        self.identifier = identifier
        self.model = model
        self.cor_len = cor_len
        self.var = var
        self.input_variogram = input_variogram
          
        #--------- Parameters -----------
        self.n    = n 
        self.m    = m 
        self.ntiles = ntiles
        self.dx00 = dx00
        self.dy00 = dy00
    
        #---------Fields -----------
        self.fields = set()
        self.field_dict = dict()
        if input_field != None:
            print("Importing field from file hax to reworked and does not work right now.")
            # self.imp_landscape(input_field)
       
        #----output directory
        self.outdir = outdir

    #intrinsic Python function to make RLC behave the right way
    def __getitem__(self,name):
        return self.field_dict[name]

    def __contains__(self, name):
        return name in self.field_dict
    
    def __len__(self):
        return len(self.fields)
    
    def __iter__(self):
        return self.fields.__iter__()
    
    def __setitem__(self, name, field):
        self.field_dict[name] = field

    def __missing__(self, key):
        if key is None:
            return list(self.field_dict.values())[-1]
        else:
            raise KeyError(key)


    #creates filepath for the field given by fieldname
    def _create_filepath(self,
                         fieldname: str,
                         outdir: str = None
    ):
        """Creates a filepath for the field given by fieldname.

        Args:
            fieldname (str): The name of the field.
            outdir (str, optional): The directory where the file should be saved. Defaults to None.

        Returns:
            str: The filepath.
        """
        lake_frac = self[fieldname].lake_frac
        bar = ""
        if self.identifier != "":
            bar = "_"
        prefix = 'land_cover_IDs_'\
                +self.identifier\
                +bar\
                +str(int(self.dx00))+'mx' +str(int(self.dy00))+'m_'\
                +str(self.n)+'x'+str(self.m)+'_'\
                +str(int(lake_frac*100)).zfill(3)+'_'\
                +str(int(self.cor_len)).zfill(4)+'m'
        
        # default outdir is the outdir of the class RLC
        if outdir == None:
            outdir = self.outdir
            
        filepath = outdir + prefix + '_' + fieldname + '.dat'
        self[fieldname].filepath = filepath
        return filepath
        
    #adds a new landscape to the class RLC
    def _add_field(self, 
                    srf, 
                    name: str, 
                    lake_frac: float = None
    ):
        """Adds a new field to the class RLC.
        Args:
            srf (class): The field to be added.
            name (str): The name of the field.
            lake_frac (float, optional): The area fraction that is water. Defaults to None.
        Returns:
            None
        """   
        new_field = _Field(srf, name, lake_frac)
        self.fields.add(new_field)
        self[name] = new_field
  
    def new_landscape(self,
                    lake_frac: float = 0.1, 
                    mode_no = "DEFAULT",
                    show_plots: bool = False,
                    sampling_size: int = 200,
                    vario_cutoff: float = 10E8,
                    seed: int = None, #20231102
                    name: str = "DEFAULT",
                    **kwargs           
    ):
        """Sets up a new landscape according to the parameters and adds it to the class RLC.

        Args:
            lake_frac (float, optional): The area fraction that is water. Defaults to 0.1.
            mode_no (str, optional): The number of modes. Defaults to "DEFAULT".
            show_plots (bool, optional): If the plots should be shown. Defaults to False.
            sampling_size (int, optional): The number of samples that are generated to
            characterize landscape to fit the variogram. Defaults to 200.
            vario_cutoff (float, optional): The maximum distance for the variogram. Defaults to 10E8.
            seed (int, optional): The seed for the random number generator. Defaults to None.
            name (str, optional): The name of the field. Defaults to "DEFAULT".
        """        
        import numpy as np
        import matplotlib.pyplot as plt
        import gstools as gs
        gs.config.NUM_THREADS = 16

        if name == "DEFAULT":
            pos = str(len(self))
            name = "landscape" + str(pos)
        
        if mode_no == "DEFAULT":
            mode_no = max(self.n, self.m)//2

        #if a variogram is given, the model is fitted to the variogram
        if self.input_variogram != None:
            print("Fitting model to variogram")
            from pandas import read_csv
            data = read_csv(self.input_variogram)
            
            # delete rows with NaN values and implement the cutoff
            data = data.dropna()
            cutoff_data = data[data['xdata'] < vario_cutoff]
            
            
            # get the distances and semivariances from the csv file
            distances = cutoff_data['xdata'].to_numpy()
            semivariances = cutoff_data['ydata'].to_numpy()

            # set the mode numebers
            print("Mode number: ", mode_no)
            #set the domain length and width
            self.dx00 = 4 * max(distances)
            self.dy00 = 4 * max(distances)

            if self.model == 'Choose':
                # fit the model to the variogram
                self.model = self.choose_model(distances, semivariances)

            #chooses the model that is used for the variogram
            model = getattr(gs, self.model)(dim=2, var=self.var, len_scale=self.cor_len)
            model.fit_variogram(distances, semivariances, nugget = False)

        #if no variogram is given, the model is used with the parameters given
        else:
            if self.model == 'Choose':
                print("Please provide a variogram or choose a model.")
                return
            #chooses the model that is used for the variogram
            model = getattr(gs, self.model)(dim=2, var=self.var, len_scale=self.cor_len)


        #the chosen model is used to create the random field
        L = np.array([self.dx00, self.dy00])
        srf = gs.SRF(model, 
                     generator = 'Fourier', 
                     mode_no = mode_no,
                     period = L,
                     seed = seed)
        
        #the grid has the size of the domain and the number of grid points
        x = np.linspace(0,self.dx00,self.n)
        y = np.linspace(0,self.dy00,self.m)
        
        print("Generating Field...")
        srf((x, y), mesh_type='structured')
        
        #the field is transformed into a binary field with the help of a threshold
        field_sorted = np.sort(srf.field,axis=None)
        num_of_cells_uw = int(lake_frac * self.n * self.m)        #number of cells underwater
        thresholds = [field_sorted[num_of_cells_uw]]             #last cell which is lake
        values     = [0, 1]                                    #lake or not lake, i.e. the question
        srf.transform("discrete", values=values, thresholds=thresholds, store="field_d")

        #adds the landscape to the class RLC
        self._add_field(srf, name, lake_frac)
        
        #plots the landscape with the lakes and without the lakes
        if show_plots: 
            self.plot_landscape(name)
            #self.plot_histogram(name)
            self.plot_variogram(name, sampling_size=sampling_size)
            
            if self.input_variogram == None:
                plt.show()
                return 
            
            fig, model_ax = plt.subplots()
            model_ax.scatter(distances, semivariances, color="black", label="Measured Data", s=10)
            model.plot(ax=model_ax, x_max=self.dx00/4, label=fr"{self.model} Fit")
            # plot the csv data as a scatter plot
            model_ax.set_title("Real World Variogram Fitted")
            model_ax.set_xlabel("Distance [m]")
            model_ax.set_ylabel("Semivariance")
            plt.show()
        

    # def imp_landscape(self,
    #                 filepath,
    #                 show_plots: bool = True
    # ):
    #     """Imports a landscape from a file.

    #     Args:
    #         filepath (str): The filepath of the file.
    #         lake_frac (float, optional): The area fraction that is water. Defaults to None.
    #         show_plots (bool, optional): If the plots should be shown. Defaults to False.
    #     """        

    #     import re
    #     from os import path
    #     from numpy import loadtxt

    #     # Use regular expression to remove file extensions
    #     filename = re.sub(r'\.(dat|shp|tif)$', '', path.basename(filepath))
    #     # the last part of the filename is the fieldname
    #     fieldname = filename.split('_')[-1]
    #     self.outdir = path.dirname(filepath)
    #     self.new_landscape(name = fieldname,
    #                          show_plots = show_plots)
    #     try:
    #         self[fieldname].values = loadtxt(filepath)
    #     except: 
    #         print("Could not be loaded.")

    def exp_landscape(self, fieldname = "ALL", outdir = None):
        """Exports the landscape to a file.
        
        Args:
            fieldname (str, optional): The name of the landscape. Defaults to "ALL".
            outdir (str, optional): The output directory. Defaults to None.
        """
                
        from numpy import savetxt
        def _exp_one_landscape(fieldname, outdir): 
            filepath = self._create_filepath(fieldname, outdir = outdir)
            savetxt(filepath, self[fieldname].values, fmt="%d")

        #export only the landscape given by fieldname
        if fieldname != "ALL":
            _exp_one_landscape(fieldname, outdir)
            return
        
        #export all landscapes stored in the class RLC if not fieldname is given
        for field in self:
            _exp_one_landscape(field.name, outdir)


    def plot_landscape(self, landscape_name = None):
        """Plots the landscape.
        
        Args:
            landscape_name (str, optional): The name of the landscape. Defaults to None.
        """        
        import matplotlib.pyplot as plt
        import matplotlib.colors as mcolors

        # Returns the last landscape if landscape_name is None
        landscape = self[landscape_name].srf

        # Topography graphic
        fig1, ax1 = plt.subplots(figsize=(10, 8))  # Set figure size
        im = ax1.imshow(landscape.field, cmap='terrain', 
                        extent=[0, landscape.pos[0][-1]/1e3, 0, landscape.pos[1][-1]/1e3])
        ax1.set_title("Generated Topography")
        ax1.set_xlabel("x [km]")
        ax1.set_ylabel("y [km]")
        # Set colorbar
        cbar = plt.colorbar(im, ax=ax1)
        cbar.set_label("Elevation [m]")

        # Ensure axes are displayed
        ax1.set_xlim([0, landscape.pos[0][-1]/1e3])
        ax1.set_ylim([0, landscape.pos[1][-1]/1e3])

        # Binary Water Mask Graphic
        fig2, ax2 = plt.subplots(figsize=(10, 8))  # Set figure size
        # Create a custom colormap
        cmap = mcolors.ListedColormap(['blue', 'lightgreen'])  # '0' is blue, '1' is lightgreen
        im = ax2.imshow(landscape.field_d, cmap=cmap, 
                        extent=[0, landscape.pos[0][-1]/1e3, 0, landscape.pos[1][-1]/1e3])
        # Add a colorbar
        cbar = plt.colorbar(im, ticks=[0, 1], ax=ax2) 
        cbar.ax.set_yticklabels(['Lake', 'Grassland'])  # Label the ticks

        ax2.set_title("Binary Water Mask")
        ax2.set_xlabel("x [km]")
        ax2.set_ylabel("y [km]")

    def plot_histogram(self, landscape_name = None):
        """Plots the histogram of the landscape.

        Args:
            landscape_name (str, optional): The name of the landscape. Defaults to None.
        """        
        import matplotlib.pyplot as plt
        #returns the last landscape if landscape_name is None
        landscape = self[landscape_name].srf
        plt.hist(landscape.all_fields[0].flatten('C'),bins=64,density=True)

    def plot_variogram(self, 
                       landscape_name = None,
                       sampling_size = 200
        ):
        """Plots the variogram of the landscape.

        Args:
            landscape_name (str, optional): The name of the landscape. Defaults to None.
            sampling_size (int, optional): The number of samples that are generated to
            characterize landscape to fit the variogram. Defaults to 200.
        """        
        import numpy as np
        import matplotlib.pyplot as plt
        import gstools as gs
        gs.config.NUM_THREADS = 16
        
        #returns the last landscape if landscape_name is None
        landscape = self[landscape_name].srf

        x = np.linspace(0,self.dx00,self.n)
        y = np.linspace(0,self.dy00,self.m)   
        
        field = landscape.all_fields[0] 
        r_max = self.dx00 / 4
        bins = np.arange(0, r_max, r_max / 64)
        print("Estimating Variogram...")
        bin_center, gamma = gs.vario_estimate((x,y),
                                            field,
                                            bins,
                                            mesh_type='structured',
                                            sampling_size=sampling_size)

        # fit the variogram with a stable model. (no nugget fitted)
        fit_model = getattr(gs, self.model)(dim=2, var=self.var, len_scale=self.cor_len)
        fit_params, others = fit_model.fit_variogram(bin_center, gamma, nugget=False)
        print("-"*50)
        print("Fitted model: ", fit_model)
        print("Variance: ", fit_params['var'])
        print("Length scale: ", fit_params['len_scale'])
        print("-"*50)

        
        fig, ax3 = plt.subplots()
        ax3.scatter(bin_center, gamma, color="black", label="Sampled Data", s=10)
        fit_model.plot(ax=ax3, x_max=r_max, label=fr"{self.model} Fit")
        ax3.set_title("Calculated Variogram Fitted")
        ax3.set_xlabel("Distance [m]")
        ax3.set_ylabel("Semivariance")
        
    def choose_model(self, distances, semivariances):
        """Chooses the best model for the variogram.

        Args:
            distances (float): The distances of the semivariances.
            semivariances (float): The semivariances.
        """        
        import matplotlib.pyplot as plt
        import gstools as gs
        gs.config.NUM_THREADS = 16
        
        models = {
            "Gaussian": gs.Gaussian,
            "Exponential": gs.Exponential,
            "Matern": gs.Matern,
            #"Stable": gs.Stable,
            #"Rational": gs.Rational, #has a bug
            "Circular": gs.Circular,
            "Spherical": gs.Spherical,
            "SuperSpherical": gs.SuperSpherical,
            "JBessel": gs.JBessel,
         }
        scores = {}
       # fit all models to the estimated variogram
        for model in models:
            fit_model = models[model](dim=2)
            para, pcov, r2 = fit_model.fit_variogram(distances, semivariances, return_r2=True)
            #fit_model.plot(x_max=self.dx00, ax=ax)
            scores[model] = r2
        ranking = sorted(scores.items(), key=lambda item: item[1], reverse=True)
        print("RANKING by Pseudo-r2 score")
        for i, (model, score) in enumerate(ranking, 1):
            print(f"{i:>6}. {model:>15}: {score:.5}")

        return ranking[0][0]
    
    def get_stats(self,
                  fieldnames: tuple[str] = "ALL",
                  outdir: str = None,
                  save_files: bool = False
    ):
        """Returns the number of lakes, the mean and the variance of the lake size distribution.

        Args:
            fieldnames (tuple[str], optional): The names of the fields. Defaults to "ALL".
            outdir (str, optional): The output directory. Defaults to None.
            save_files (bool, optional): If the files should be saved. Defaults to False.
        Returns:
            tuple: The number of lakes, the mean and the variance of the lake size distribution.
        """            
       
        from osgeo import gdal, ogr, osr
        import numpy as np
        gdal.UseExceptions()    # Enable exceptions
        
        if fieldnames == "ALL":
            fieldnames = [field.name for field in self]
        # Number of dublicates in one direction 
        all_number_of_lakes = []
        all_mean_lake_size = []
        all_variance_lake_size  = []

        for fieldname in fieldnames:
            #create filepath
            self[fieldname].filepath = self._create_filepath(fieldname, outdir = outdir)
            
            # Tesselate space with tundra lake tiles
            # to minimize boundary error
            self.array2raster(fieldname=fieldname)
            self.raster2shape(fieldname=fieldname)
            areas = self.get_lakeAreas(self.ntiles**2 * self.dx00 * self.dy00)
            number_of_lakes = int((len(areas) - 1)/self.ntiles**2)
            mean_lake_size = np.mean(areas)
            variance_lake_size = np.var(areas) 
            all_number_of_lakes  = np.append(all_number_of_lakes, number_of_lakes)
            all_mean_lake_size = np.append(all_mean_lake_size, mean_lake_size)
            all_variance_lake_size  = np.append(all_variance_lake_size, all_variance_lake_size)
     
            print('Statistics for ', fieldname)
            print( '    # of lakes = ', number_of_lakes)
            print( '    mean [m2]  = ', mean_lake_size )
            print( '    var  [m4]  = ', variance_lake_size )
        
        #remove the generated files
        if save_files == False:
            import os
            for fieldname in fieldnames:
                filepath = self._create_filepath(fieldname, outdir = outdir)
                os.remove(filepath.replace('.dat','.tif'))
                os.remove(filepath.replace('.dat','.shp'))
                os.remove(filepath.replace('.dat','.shx'))
                os.remove(filepath.replace('.dat','.dbf'))
            
        return all_number_of_lakes, all_mean_lake_size, all_variance_lake_size
    
    def array2raster(
            self, 
            raster_origin: tuple[int,int] = (0,0), 
            fieldname: str = "LAST_FIELD", #do not touch when using the function externally
            raster_filepath: str = "DEFAULT",
    ):
        """Converts an array to a raster file and saves it.

        Args:
            raster_origin (tuple[int,int], optional): The origin of the raster. Defaults to (0,0).
            fieldname (str, optional): The name of the field. Defaults to "LAST_FIELD".
            raster_filepath (str, optional): The filepath of the raster file. Defaults to "DEFAULT".
        """        
        from numpy import tile
        from osgeo import gdal
        from pyproj import CRS

        gdal.UseExceptions()    # Enable exceptions
        
        #if no fieldname is specified the last field is used
        if fieldname == "LAST_FIELD":
            fieldname = list(self.field_dict.keys())[-1]
        
        #if no new raster_file is specified only the file ending is replaced
        if raster_filepath == "DEFAULT":
            raster_filepath = self[fieldname].filepath.replace('.dat','.tif') #new raster filepath
        
        array = tile(self[fieldname].values, (self.ntiles, self.ntiles))
        cols = array.shape[1]
        rows = array.shape[0]
        origin_x = raster_origin[0]
        origin_y = raster_origin[1]
    
        pixel_width = self.dy00 / self.m 
        pixel_height = self.dx00 / self.n
        
        driver = gdal.GetDriverByName('GTiff')
        out_raster = driver.Create(raster_filepath, cols, rows, 1, gdal.GDT_Byte)
        out_raster.SetGeoTransform((origin_x, pixel_width, 0, origin_y, 0, pixel_height))    
        outband = out_raster.GetRasterBand(1)
        outband.WriteArray(array)

        out_raster_sr = CRS.from_epsg(3857)
        #out_raster_sr = CRS.from_epsg(4326) # Spherical coordinates
        wkt = out_raster_sr.to_wkt()
        out_raster.SetProjection(wkt)
        outband.FlushCache()
    
    def raster2shape(self,
                     fieldname: str = "LAST_FIELD", #do not touch when using the function externally
                     shape_filepath: str = "DEFAULT"
    ):
        """Converts a raster file to a shape file and saves it.

        Args:
            fieldname (str, optional): Give the name of the field, that should be converted. Defaults to "LAST_FIELD".
            shape_filepath (str, optional): Give the filepath of the shape file. Defaults to "DEFAULT".
            
        Returns:
            None
        """        
        from osgeo import gdal, ogr, osr
        gdal.UseExceptions()    # Enable exceptions
        
        #if no fieldname is specified the last generated field is used
        if fieldname == "LAST_FIELD":
            fieldname = list(self.field_dict.keys())[-1]
        
        raster_filepath = self[fieldname].filepath.replace('.dat','.tif') #new raster filepath
        
        #if no new shape_file is specified only the file ending is replaced
        if shape_filepath == "DEFAULT":
            shape_filepath = raster_filepath.replace('.tif','.shp') #new shape filepath
        
        #  get raster datasource
        try:
            raster = gdal.Open(raster_filepath)
        except:
            print("Has no raster file")
            return None
        
        band = raster.GetRasterBand(1)
        
        proj = raster.GetProjection() # gets projection from file
        shp_proj = osr.SpatialReference()
        shp_proj.ImportFromWkt(proj)
        
        call_driver = ogr.GetDriverByName("ESRI Shapefile")
        create_shp = call_driver.CreateDataSource(shape_filepath)
        
        shp_layer = create_shp.CreateLayer('layername', srs = shp_proj)
        new_field = ogr.FieldDefn("ID", ogr.OFTInteger)
        
        shp_layer.CreateField(new_field)
        
        gdal.Polygonize(band, None, shp_layer, 0, [], callback=None)
        create_shp.Destroy()
        raster = None
    
    
    def get_lakeAreas(self,
                      totalArea,
                      fieldname: str = "LAST_FIELD" #do not touch when using the function externally
    ):
        """Calculates the areas of the lakes in the field.

        Args:
            totalArea (float): The total area of the field.
            fieldname (str, optional): The name of the field. Defaults to "LAST_FIELD". 
                                        Do not touch when using the function externally.
        Returns:
            numpy.ndarray: The areas of the lakes.
        """        
        from numpy import sum, sort
        from geopandas import read_file

        #if no fieldname is specified the last field is used
        if fieldname == "LAST_FIELD":
            fieldname = list(self.field_dict.keys())[-1]

        shape_filepath = self._create_filepath(fieldname).replace('.dat','.shp') #new shape filepath
        try:
            data = read_file(shape_filepath)
        except:
            print("Has no shape file.")
            return None

        areas = data['geometry'].area
        areas = sort(areas)
        if (sum(areas[:-1])+areas[-1] != totalArea ):
            print("The sum of the areas does not match the total area.")
            return -1
        else:
            return areas[:-1]
   
    def update_from_args(self, args):
        """Updates the class RLC with the parsed flags.
        
        Args:
            args (argparse.Namespace): The parsed flags.
        """
        #remove None values from the flags
        flags_dict = {key: value for key, value in vars(args).items() if value is not None} 
        for key, value in flags_dict.items():
            if value is None:  # Only override if explicitly set
                continue
            else: setattr(self, key, value)
        return flags_dict
    
def flag_parser():
    """Parses the flags given in the command line.

    Returns:
        argparse.Namespace: The parsed flags.
    """        
    import argparse
    # all propeties of the class RLC can be set here
    parser = argparse.ArgumentParser(description='Random Landcover Generator')
    parser.add_argument('-c','--RUN_CODE', type=int, default=0,
                        help='Choose a case. Zero for normal flag use.\
                            One for a Gaussian variogram. Two for a variogram from a csv file.')
    parser.add_argument('-p','--show_plots', action="store_true",
                        help='Show plots.')
    parser.add_argument('-s','--save', action="store_true",
                        help='Save field.')
    parser.add_argument('-lf', '--lake_frac', type=float,
                        help='The areal fraction of the generated landcover that will be water.')
    parser.add_argument('-cl','--cor_len', type=int,
                        help='The correlation length of the variogram.')
    parser.add_argument('-v', '--var', type=int,
                        help='The variance of the variogram.')
    parser.add_argument('-id','--identifier', type=str,
                        help='identifier')
    parser.add_argument('-iv', '--input_variogram', type=str,
                        help='Loads a variogram from a csv file file which filepath is specified.')
    parser.add_argument('-if', '--input_field', type=str,
                        help='Loads a field from a dat file which filepath is specified.')
    parser.add_argument('-m', '--model', type=str,
                        help='The model used for the variogram.')
    parser.add_argument('-sz', '--sampling_size', type=int,
                    help='The number of samples that are generated to characterize landscape to fit the variogram.')
    parser.add_argument('-vc', '--vario_cutoff', type=float,
                    help='The maximum distance for the variogram.')
    parser.add_argument('-nx', '--n', type=int,
                        help='Number of grid points in x-direction.')
    parser.add_argument('-ny', '--m', type=int,
                        help='Number of grid points in y-direction.')
    parser.add_argument('-dx', '--dx00', type=float,
                        help='Domain length in x-direction.')
    parser.add_argument('-dy', '--dy00', type=float,
                        help='Domain length in y-direction.')
    parser.add_argument('-nt', '--ntiles', type=int,
                        help='Number of tiles.')
    parser.add_argument('-out', '--outdir', type=str,
                        help='Output directory.')
    return parser.parse_args()
        
if __name__ == "__main__":
    flags = flag_parser()
    RUN_CODE = flags.RUN_CODE
    match RUN_CODE:
        case 0:
            #generate a new landscape, input by flags
            rlc = RLC()
            flags_dict = rlc.update_from_args(flags)
            rlc.new_landscape(**flags_dict)
            rlc.get_stats()
        
        case 1:
            #Example one: generate a new landscape with a Gaussian variogram
            rlc = RLC(model="Gaussian", cor_len=10, var=4)
            rlc.new_landscape(lake_frac=0.4, show_plots=True)
            rlc.get_stats()
        
        case 2: 
            #Example two: generate a new landscape from a Variogram
            rlc = RLC(input_variogram="./variograms/var_Chersky1_DEM_250.csv", model="Choose")
            rlc.new_landscape(lake_frac=0.1, show_plots=True)
            rlc.get_stats()
        
        case 3:
            #Example three: Comparision with LS3
            rlc = RLC(input_variogram="./variograms/var_Chersky1_DEM_250.csv",
                    model="Matern"
            )
            rlc.dx00 = 8000
            rlc.dy00 = 8000
            rlc.n = 256
            rlc.m = 256
            rlc.new_landscape(lake_frac=0.1, 
                              show_plots=True, 
                              vario_cutoff=2000,
                              mode_no=[128,128],
                              seed=1681903
            )
            rlc.get_stats()
        case 4:
            # Your own setup :D
            pass


